---
title: ""
subtitle: ""

date: "09-05-2025"
author:
  - "Line A. Adolph"
  - "Maria B. A. Hitz"
  - "Maria Cristiana Maxim"
  - "Martin E. Bindner"
  - "Abdikadir A. M. H. Omar"
  
format: 
  pdf:
    toc: false
    toc-title: Indholdsfortegnelse
    toc-depth: 4
    number-sections: true
    number-depth: 4
    fontsize: 12pt
    mainfont: Times New Roman
    linestretch: 1.5
    geometry:
      - top=30mm
      - left=20mm
      - right=20mm
      - bottom=30mm
      - heightrounded
---

\renewcommand{\contentsname}{Indholdsfortegnelse}
\newpage

```{r}
#| label: setup
#| include: false
#| warning: false
#| 

# eval: false prevents code from being evaluated. (And obviously if the code is not run, no results will be generated). This is useful for displaying example code, or for disabling a large block of code without commenting each line.

# include: false runs the code, but doesn’t show the code or results in the final document. Use this for setup code that you don’t want cluttering your report.

# echo: false prevents code, but not the results from appearing in the finished file. Use this when writing reports aimed at people who don’t want to see the underlying R code.

# Du kan lave code chunks med crtl/alt/I. 
# Angiv en label som ovenfor til hver chunk. 
# Brug evt. include, eval, echo eller en anden parameter til at få det ønskede output

pacman::p_load(
    dplyr,         # til datamanipulation
    tidyr,         # til fx split af kolonner
    stringr,        # til teksthåndtering
    tidyverse,     # samlet pakke til dataanalyse (inkl. ggplot2, tibble, mm.)
    skimr,         # oversigtsstatistik
    readxl,        # læsning af Excel-filer
    hms,           # håndtering af tid
    ggpubr,        # ggplot med publikationstema
    ggfortify,     # autoplot til modeller
    GGally,        # udvidelse af ggplot, fx ggpairs
    gridExtra,     # arrangering af plots
    hrbrthemes,    # moderne ggplot-temaer
    table1,        # flot tabel 1 output
    tidymodels,    # samlet ML-framework
    themis,        # håndtering af ubalancerede data
    broom,         # konvertering af modeller til tidy-format
    caret,         # klassisk ML-framework
    discrim,       # diskriminantanalyse
    glmnet,        # regulerede regressioner
    kknn,          # k-NN klassifikation/regression
    naivebayes,    # naive bayes modeller
    kernlab,       # kernelbaserede metoder inkl. SVM
    xgboost,       # gradient boosting
    ranger,        # hurtig random forest
    gbm,           # gradient boosting machines
    randomForest,  # klassisk random forest
    rpart,         # beslutningstræer
    leaps,         # modelselektionsmetoder
    car,           # diagnostik for lineære modeller
    PerformanceAnalytics, # performance-metrics (især finans)
    rvest,         # web scraping
    httr,          # HTTP requests
    jsonlite,      # arbejde med JSON
    rjson,         # alternativ JSON-pakke
    rlist,         # listehåndtering
    Rcrawler,      # web crawling
    rmarkdown,     # rapportgenerering
    knitr,         # knit Rmd-dokumenter
    future         # parallelisering og asynkron kodning
    
)
```

\begin{titlepage}
\begin{center}

\includegraphics[width=18cm]{images/churn_cover.png}

\vspace{0.5cm}

{\large \textbf{Forfattere:}}\\
Line A. Adolph, Maria B. A. Hitz, Maria Cristiana Maxim, Martin Bindner, Abdikadir A. M. H. Omar

\vspace{0.5cm}

{\large \textbf{1. interne eksamensprojekt}} \\
Vejleder: Simon Bjerrum Eilersen

\vspace{0.5cm}

{\large \textbf{Dato: 9. maj 2025}}

\vfill

{\large \textbf{Antal tegn: xx.xxx}}

\end{center}
\end{titlepage}

\newpage

\tableofcontents
\newpage

# Resumé

# Indledning

Business Viborg er registreret under branchekoden 26104793, og arbejder målrettet for at skabe optimale rammer for erhvervslivet i Viborg Kommune. Som en medlemsorganisation med over 600 virksomheder i ryggen, er relationerne til medlemskredsen helt afgørende, både for at dele viden, styrke netværk og skabe lokal vækst.I forbindelse med præsentationen af Business Viborg udtalte chefkonsulent Michael Freundlich: “Vores mål for 2025 er at nå 700 medlemmer og en omsætning på 2,9 mio. kr.”

Men når virksomheder melder sig ud, mister Business Viborg ikke kun en indtægt, men også værdifulde forbindelser, politisk legitimitet og mulighed for at gøre en forskel for erhvervslivet i området. For at handle proaktivt ønsker Business Viborg at få bedre indsigt i, hvad der driver churn og hvem der er i risikozonen. 

Derfor skal der udvikles et datadrevet værktøj, som kombinerer teknisk analyse med brugervenlig indsigt. Et værktøj, der gør det muligt for både medlemskonsulenter og ledelse at træffe kloge beslutninger og handle i tide med respekt for både dataetik og jura.


# Problemformulering

Hvordan kan Business Viborg analysere og anvende medlemsdata til at udvikle et beslutningsunderstøttende dashboard, der forudsiger churn og forklarer centrale risikofaktorer baseret på relevante maskinlæringsmetoder og med inddragelse af etiske og juridiske overvejelser?

## Underspørgsmål

**Eksplorativ analyse (EDA)**

Beskriv hvilke mønstre og karakteristika kendetegner de virksomheder, der forlader Business Viborg?

**Modelvalg og performance**

Hvordan kan forskellige machine learning-modeller anvendes til at forudsige churn i Business Viborgs kontekst, og hvilke modeller er mest velegnede?

**Datavisualisering**

Hvordan kan resultater og churn-indsigter formidles via et brugervenligt dashboard, som understøtter daglig opsøgende indsats for medlemskonsulenter og ledelse?

**Etik og jura**

Hvilke juridiske krav (fx GDPR) og etiske overvejelser bør indgå i udviklingen og brugen af et churn-forudsigelsesværktøj baseret på medlemsdata?


# Afgrænsning

## AI Chatbots
I forbindelse med udarbejdelsen af projektet er ChatGPT 4.0 blevet anvendt som et værktøj til grammatisk og sproglig korrektur, idéudvikling samt forbedring af det sproglige udtryk. Modellen har udelukkende fungeret som et hjælpemiddel i arbejdet med tekstbaserede opgaver og har hverken erstattet selvstændig analyse, kritisk refleksion eller været brugt til direkte besvarelse af problemformuleringen

I dette projekt fokuserer vi på at udvikle en webbaseret applikation, der kan forudsige medlems-churn og visualisere centrale churn-drivere for Business Viborg. Projektet indebærer derfor flere afgrænsninger.

## Data
Vi anvender udelukkende datasættet, som er udleveret af Business Viborg. Datasættet indeholder information om medlemskab, virksomhedsstørrelse, branche, engagementsniveau, kontaktfrekvens og deltagelse i arrangementer. Dataene er anonymiserede og begrænset til et specifikt tidsrum, hvilket kan påvirke modellens generaliserbarhed.

## Modeller
Projektet fokuserer på udvikling og afprøvning af machine learning-modeller til churn-prediktion, herunder blandt andet Random Forest, XGBoost og Lasso. Vi anvender bootstrapping som resampling-metode og benytter AUC og accuracy som de primære evalueringsmål. Fokus er på modellens forklaringskraft og praktiske anvendelighed frem for at optimere for den højest mulige præcision.

## Webapplikation
Applikationen er en prototype og er ikke integreret med Business Viborgs IT-systemer eller databaser. Den kan uploades og anvendes lokalt eller via RStudio Cloud.

## Etik og jura
Vi behandler kort de etiske og juridiske aspekter ved brugen af persondata i overensstemmelse med GDPR, men foretager ikke en fuld juridisk gennemgang. Implementering af samtykke- og adgangsstyring indgår ikke som en del af denne prototype.


# Definitioner

# Analyse

# Juridiske og etiske overvejelser

## Juridiske og etiske forhold i churn-projektet for Business Viborg
I forbindelse med udviklingen af en datadrevet løsning til forudsigelse af 
medlems-churn hos Business Viborg er det essentielt, at både juridiske og etiske
hensyn bliver nøje overvejet og integreret i hele udviklingsprocessen. 
Den teknologiske og analytiske dimension af projektet må ikke stå alene, 
men skal suppleres af en bevidsthed om datasikkerhed, individets rettigheder og 
ansvarlig brug af data. Da løsningen tager udgangspunkt i oplysninger om 
organisationens medlemmer, der potentielt kan knyttes til 
identificerbare personer, er databehandlingen omfattet af 
EU’s Databeskyttelsesforordning (GDPR). 
Dette gælder, uanset om data fremstår pseudonymiserede for os som analytikere, 
da Business Viborg internt kan koble data til konkrete virksomheder eller 
kontaktpersoner. Formålet med dette afsnit er derfor at belyse de centrale 
juridiske forpligtelser samt de etiske retningslinjer, som Business Viborg bør 
overholde i forbindelse med udviklingen og implementeringen af churn-modellen.

## Behandlingsgrundlag
Et fundamentalt krav i GDPR er, at al behandling af personoplysninger skal 
have et lovligt behandlingsgrundlag. Business Viborgs databehandling relaterer 
sig til almindelige personoplysninger såsom virksomhedsnavne, 
kontaktoplysninger, mødedeltagelse og interaktionshistorik. 
Det er derfor nødvendigt at vurdere, hvilket hjemmelsgrundlag der gør det 
lovligt at anvende disse data i en churn-model. Ifølge artikel 6 i GDPR kan 
behandlingen enten baseres på samtykke fra medlemmerne (art. 6, stk. 1, litra a)
eller på organisationens legitime interesser (art. 6, stk. 1, litra f). 
I denne kontekst vurderes det, at Business Viborg primært bør benytte den 
legitime interesse som behandlingsgrundlag, da organisationens formål – at 
forbedre medlemsservice, understøtte fastholdelse og sikre et bæredygtigt 
erhvervsfællesskab – er både sagligt, proportionalt og foreneligt med 
medlemmernes forventninger.
Det er dog vigtigt at bemærke, at hvis data senere anvendes til andre formål, 
f.eks. målrettet markedsføring eller automatiseret profilering,
kan det være nødvendigt at genoverveje behandlingsgrundlaget, 
herunder at indhente eksplicit samtykke.

## Personoplysninger og dataminimering
Analyserne tager udgangspunkt i almindelige personoplysninger, 
som ikke i sig selv er følsomme, men som i kombination med andre oplysninger 
stadig udgør personoplysninger i GDPR-forstand. 
Eksempler kan være data om deltagelse i arrangementer, 
mødeaktivitet eller medlemskabets varighed. 
For at overholde principperne om dataminimering 
og formålsbegrænsning (jf. GDPR art. 5), skal Business Viborg sikre, 
at der kun behandles data, som er nødvendige og relevante i forhold til det 
definerede formål – nemlig at kunne identificere virksomheder i 
risiko for udmeldelse. Alle unødvendige oplysninger bør fjernes eller 
anonymiseres, og det samlede datasæt skal reduceres til det minimum, der kræves 
for at modellere churn med høj præcision.
Derudover skal der være dokumentation for, hvordan og hvorfor de valgte 
variabler indgår i modellen. Denne dokumentation skal kunne anvendes til 
intern kontrol og overfor Datatilsynet, hvis der føres tilsyn.

## Oplysningspligt og transparens
Business Viborg har i henhold til GDPR artikel 13 og 14 en klar oplysningspligt
over for de registrerede medlemmer. Det betyder, at medlemmerne skal informeres 
om, at deres data indgår i analyser, hvad formålet med analysen er, hvilke 
rettigheder de har, og hvordan de kan kontakte organisationen for spørgsmål 
eller indsigelser. Oplysningen bør være let tilgængelig og formuleret i et 
sprog, der er forståeligt for ikke-specialister. 
Ideelt set bør informationen formidles både via organisationens 
privatlivspolitik og i forbindelse med medlemskommunikation – f.eks. 
i velkomstmateriale eller nyhedsbreve.
Transparens er i denne sammenhæng ikke blot et juridisk krav, 
men også et middel til at styrke medlemmernes tillid til 
Business Viborgs databrug.


## Pseudonymisering og identifikationsrisici
Selvom datasættet, som analysen baseres på, er pseudonymiseret for 
dataanalytikerne, betyder det ikke, at oplysningerne er anonyme i GDPR-forstand.
Business Viborgs medarbejdere har adgang til nøgleoplysninger 
såsom medlemsnummer, virksomhedsnavn eller kontaktpersoner, som gør det 
muligt at identificere de registrerede. Dette understreger, at databehandlingen
fortsat er omfattet af alle GDPR-krav. Der skal derfor træffes passende 
forholdsregler for at sikre, at oplysningerne ikke anvendes til andre formål 
uden nyt behandlingsgrundlag og ikke utilsigtet afslører følsom information 
om specifikke virksomheder.


## Datasikkerhed og organisatorisk ansvar
Business Viborg er som dataansvarlig forpligtet til at beskytte 
personoplysninger mod uautoriseret adgang, tab, ændring eller misbrug. 
I henhold til artikel 24 og 32 i GDPR skal organisationen iværksætte både 
tekniske og organisatoriske sikkerhedsforanstaltninger. 
Det inkluderer brug af adgangsstyring, kryptering, logning af datatilgange, 
opdaterede sikkerhedspolitikker og uddannelse af personale i datasikkerhed. 
Derudover skal der foreligge databehandleraftaler, hvis eksterne 
samarbejdspartnere inddrages i projektet. 
Manglende sikkerhed kan ikke alene få juridiske konsekvenser, 
men også underminere den tillid, som projektet skal baseres på.

## Etiske overvejelser og ansvarlig dataanvendelse
Udover den juridiske ramme bør Business Viborg også forholde sig aktivt til 
dataetik og samfundsansvar. Ifølge anbefalinger fra bl.a. 
Dataetisk Råd handler ansvarlig dataanvendelse om at sætte mennesket i centrum, 
sikre gennemsigtighed og undgå skævvridning eller diskrimination. 
Anvendelsen af en churn-model må ikke resultere i, at bestemte virksomheder 
eller grupper automatisk vurderes som mindre værdifulde baseret på statistiske 
mønstre, som ikke er sagligt begrundede. Der skal derfor tages højde for 
fairness og risikoen for bias – både i datasættets sammensætning og i de 
variable, der anvendes i modellen.



# Anbefaling

# Konklusion

# 

\newpage

# Literaturliste

**AI**

OpenAI. (2025). ChatGPT (4.0). <https://chatgpt.com/>

**Bøger**

**WWW-dokumenter**

**Undervisningsmaterialer**

\newpage

# Bilagsoversigt

-   Bilag 1: x
-   Bilag 2: x
-   Bilag 3: x
-   Bilag 4: x
-   Bilag 5: x
-   Bilag 6: x

\newpage

```

1. Data load
```{r}
# ------------------------------------------------------------------------------
# 1. Load data
# ------------------------------------------------------------------------------

# Indlæser alle nødvendige datasæt
meetings <- readRDS("data/meetings.rds")
events <- readRDS("data/events.rds")
event_participants <- readRDS("data/event_participants.rds")
company_contacts <- readRDS("data/company_contacts.rds")
all_contact <- readRDS("data/all_contact.rds")
all_companies <- readRDS("data/all_companies.rds")
old_projects <- readRDS("data/old_projects.rds")

```


2. Merge datasets
```{r}
# ------------------------------------------------------------------------------
# 2.1: Fjern dubletter og behold første registrering pr. virksomhed
# ------------------------------------------------------------------------------
meetings_unique <- meetings |>
  group_by(CompanyId) |> 
  summarise(across(everything(), first))    # Første møde pr. virksomhed

events_unique <- events |>
  group_by(Cvr) |> 
  summarise(across(everything(), first))    # Første event pr. virksomhed

event_participants_unique <- event_participants |>
  group_by(Cvr) |> 
  summarise(across(everything(), first))    # Første deltagerinfo pr. virksomhed



# ------------------------------------------------------------------------------
# 2.2: Saml alle datasæt med left_join og ryd op i dubletter
# ------------------------------------------------------------------------------
merged_df <- all_companies |> 
  left_join(company_contacts, by = "CompanyId") |>     # Join kontaktpersoner
  left_join(all_contact, by = "contactId") |>          # Join kontaktinfo
  left_join(meetings_unique, by = "CompanyId") |>      # Join mødedata
  rename(Cvr = "z_companies_1_CVR-nummer_1") |>        # Omdøber kolonnen til 
                                              # "Cvr", så den matcher med events
  left_join(events_unique, by = "Cvr") |>              # Join eventinfo
  left_join(event_participants_unique, by = "Cvr") |>  # Join deltagerinfo
  select(-ends_with(".y"), -ends_with(".x"))           # Fjerner dublet-kolonner


# ------------------------------------------------------------------------------
# 2.3: Klargør datasæt: fjern anonyme oplysninger og omdøb kolonnenavne
# ------------------------------------------------------------------------------
# Viser overblik over datasættet og datatyper
glimpse(merged_df)

# Fokus: Unikke virksomheder via PNumber (produktionsenhedsnummer)
# Det giver os 2966 unikke observationer.
merged_df <- merged_df |> 
  select(-z_companies_1_Firmanavn_1, -z_contacts_1_Email_1)  
# Fjerner anonymiserede data

# Standardiser kolonnenavne for overskuelighed
colnames(merged_df) <- c(
  "BusinessCouncilMember", "CompanyDateStamp", "CompanyId", "CompanyType",
  "CVR", "Employees", "PostalCode", "CompanyTypeName", "PNumber", "Country",
  "NACECode", "CompanyStatus", "AdvertisingProtected", "ContactId",
  "CompanyOwnerId", "ContactLastUpdated", "TitleChanged", "LocationChanged",
  "CreatedBy", "MeetingLength", "Firstname", "UserRole", "Initials",
  "EventExternalId", "EventPublicId", "Description", "LocationId",
  "MaxParticipants", "EventLength", "EventId"
)

# ------------------------------------------------------------------------------
# 2.4: Fjern dubletter og irrelevante kolonner
# Udfyld manglende værdier i eventkolonner med "Ingen event"
# ------------------------------------------------------------------------------

# Beholder unikke virksomheder, fjerner irrelevante kolonner,
# og udfylder NA i eventdata
merged_unique <- merged_df |>
  distinct(PNumber, .keep_all = TRUE) |>  # Beholder én række pr. PNumber
  select(-TitleChanged, -LocationChanged, -CreatedBy, -Firstname,  
         # Fjerner irrelevante variabler
         -UserRole, -Initials, -ContactLastUpdated) |>
  mutate(across(  # Erstatter NA i event-kolonner med "Ingen event"
    c(MeetingLength, EventExternalId, EventPublicId, Description, 
      LocationId, MaxParticipants, EventLength, EventId),
    ~ if_else(is.na(.), "Ingen event", as.character(.))
  ))

# Rens MeetingLength og konverter til numerisk (fjern " mins")
merged_unique <- merged_unique |> 
  mutate(
    MeetingLength = ifelse(MeetingLength == "Ingen event", "0 mins", 
                           MeetingLength), 
    MeetingLength = as.numeric(str_remove(MeetingLength, " mins"))
  )
  
# ------------------------------------------------------------------------------
# 2.5: Splitter NACECode i kode og beskrivelse, 
# fjern original kolonne og NA-rækker
# ------------------------------------------------------------------------------
merged_unique <- merged_unique |>
  mutate(
    Employees   = if_else(is.na(Employees), "Ukendt", as.character(Employees)),
    # NA -> "Ukendt"
    
    NACECode    = if_else(is.na(NACECode),  "Ukendt", as.character(NACECode)),
    # NA -> "Ukendt"
    
    Nacecode    = if_else(NACECode == "Ukendt", "Ukendt", 
                          str_extract(NACECode, "^[0-9]+")),                 
    # Hent kode
    Nacebranche = if_else(NACECode == "Ukendt", "Ukendt", 
                          str_remove(NACECode, "^[0-9]+\\s*"))               
    # Hent branche
  ) |>
  select(-NACECode) |>  # Fjerner original NACECode-kolonne
  na.omit()             # Fjerner rækker med NA-værdier

# ------------------------------------------------------------------------------
# 2.6: Tjek for tilbageværende NA-værdier
# ------------------------------------------------------------------------------
colSums(is.na(merged_unique))


# ------------------------------------------------------------------------------
# 2.7: Gem det rensede datasæt til senere brug
# ------------------------------------------------------------------------------
saveRDS(merged_unique, "merged_unique.rds")

# ------------------------------------------------------------------------------
# 2.8: Merge old_projects (frivillig) med virksomhedsdata
# ------------------------------------------------------------------------------

# Omdøb SMVContactId til ContactId
old_projects <- old_projects |>
  rename(ContactId = SMVContactId) # Omdøb kolonne for at matche join

# Gem kolonnenavne fra old_projects (ekskl. ContactId)
old_project_cols <- setdiff(names(old_projects), "ContactId")
cols_to_fill <- setdiff(old_project_cols, c("Id", "SMVCompanyId", "SharedWith"))

# Join med merged_unique og erstat NA med "Tom"
merged_unique_old_projects <- merged_unique |>
  left_join(old_projects, by = "ContactId") |>   # Merger på ContactId
  select(-Id, -SMVCompanyId, -SharedWith) |>     # Fjerner unødvendige kolonner
  mutate(across(all_of(cols_to_fill), 
                ~ if_else(is.na(.), "Tom", as.character(.)))) |> # NA → "Tom"
  distinct(PNumber, .keep_all = TRUE)            # Behold unikke virksomheder

# ------------------------------------------------------------------------------
# 2.9: Tjek for NA-værdier i det udvidede datasæt
# ------------------------------------------------------------------------------
colSums(is.na(merged_unique_old_projects))

merge_datasets <- merged_unique_old_projects
```

3. Clean data
```{r}
# ------------------------------------------------------------------------------
# 3.1: Første kig på datastrukturen
# Giver et hurtigt overblik over variabelnavne, typer og eksempelværdier
# ------------------------------------------------------------------------------
glimpse(merge_datasets)



# ------------------------------------------------------------------------------
# 3.2: Tæl hvor mange NA (manglende værdier) der findes i hver kolonne
# Dette er nyttigt for at forstå, hvor der evt. skal renses eller imputeres
# ------------------------------------------------------------------------------
# Tjekker for manglende værdier (NA) i alle variabler
na_count <- merge_datasets |> 
  summarise(across(everything(), ~ sum(is.na(.)))) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "na_count")

# ------------------------------------------------------------------------------
# 3.3: Rensning af kolonnenavne
# Fjerner forstyrrende elementer som tal, specialtegn og mellemrum
# Gør kolonnenavne nemmere at bruge i videre analyser og modeller
# ------------------------------------------------------------------------------
# Rydder op i variabelnavne: fjerner tal, specialtegn og whitespace
names(merge_datasets) <- names(merge_datasets) |>
  str_remove("^[0-9]+_1*\\s*") |>     # Fjerner startende tal/1-taller
  str_replace_all("[ /\\-]+", "_") |> # Erstatter mellemrum og specialtegn med _
  str_replace_all("_+", "_") |>       # Fjerner dobbelte underscores
  str_remove("_$") |>                 # Fjerner underscore i slutningen
  str_trim()                          # Trim whitespace

# Udskriver de rensede kolonnenavne
print(names(merge_datasets))

# ------------------------------------------------------------------------------
# 3.4: Fjern irrelevante kolonner (ID’er og tekniske felter)
# Disse kolonner bruges ikke i analysen og fjernes derfor fra datasættet
# ------------------------------------------------------------------------------
clean_data <- merge_datasets |> 
  dplyr::select(-ContactId, -CompanyOwnerId, -EventExternalId,
                -EventPublicId, -LocationId, -Tekstfelt, -CompanyType)

# ------------------------------------------------------------------------------
# 3.5: Erstatning og konvertering af værdier
# - Tekst som "Tom", "Ukendt" og "Ingen event" → NA
# - NA i tekstfelter bliver til "Ukendt"
# - NA i tal bliver til 0
# - Udvalgte kolonner konverteres til numerisk format
# ------------------------------------------------------------------------------
clean_data <- clean_data |>
  mutate(
    across(
      c(CVR, Nacecode, PostalCode, PNumber, MaxParticipants, 
        EventLength, Employees), ~ as.numeric(ifelse(.x %in% c(" ", "", "Tom", 
                                            "Ukendt", "Ingen event"), NA, .x))
    ),
    across(where(is.character), ~ replace_na(.x, "Ukendt")), # Tekst: NA → 
    # "Ukendt"
    across(where(is.numeric), ~ replace_na(.x, 0))             # Tal: NA → 0
  )

# ------------------------------------------------------------------------------
# 3.6: Konverter dato-kolonner til rigtig datoformat
# Vigtigt hvis man senere skal beregne fx forskel i tid
# ------------------------------------------------------------------------------
CompanyDateStamp <- as.Date(clean_data$CompanyDateStamp, format = "%Y-%m-%d")
Kontaktdato      <- as.Date(clean_data$Kontaktdato, format = "%Y-%m-%d")




# ------------------------------------------------------------------------------
# 3.7: # Viser datastruktur efter rensning
# ------------------------------------------------------------------------------
glimpse(clean_data)
```

4. Feature Engineering
```{r}

# ------------------------------------------------------------------------------
# 4.1: # Viser datastruktur efter rensning
# ------------------------------------------------------------------------------

glimpse(clean_data) # Bruger glimpse til at få et hurtigt overblik over data


# ------------------------------------------------------------------------------
# 4.2: Opretter en ny variabel, der beregner hvor mange år 
# en virksomhed har været medlem. Vi bruger CompanyDateStamp (oprettelsesdato)
# og beregner forskellen til dags dato.
# ------------------------------------------------------------------------------
feature_engineering <- clean_data |>
  mutate(
    medlem_antal_år = round(
      as.numeric(difftime(Sys.Date(), as.Date(CompanyDateStamp), 
                          units = "days")) / 365, 
      0
    )
  )
  

# ------------------------------------------------------------------------------
# 4.3: Rensning af Employees-kolonnen (antal ansatte). 
# Nogle gange kan tal være formateret med punktummer (f.eks. "1.000") 
# eller mellemrum (f.eks. "1 000"). 
# Disse fjernes, så kolonnen kan konverteres til numerisk format
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
    Employees = Employees |> 
      str_replace_all("\\.", "") |>       # Fjerner punktummer
      str_replace_all("\\s+", "") |>      # Fjerner mellemrum
      as.numeric()                        # Konverterer til tal
  )

# ------------------------------------------------------------------------------
# 4.4: Oversættelse af virksomhedstyper til mere læsbare formater
# Eksempel: "A/S" bliver til "Aktieselskab"
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
CompanyTypeName = str_replace_all(CompanyTypeName, "A/S", "Aktieselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "ApS", "Anpartsselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "IVS", "Iværksætterselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "P/S", "Partnerselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "K/S", "Kommanditselskab")
  )

# ------------------------------------------------------------------------------
# 4.5: Tilføj branchebetegnelse baseret på NACE-koder
# NACE er en standard for brancheklassifikation (fx "01 Landbrug")
# Vi bruger de første to cifre til at matche mod en lookup-tabel med branchenavne
# ------------------------------------------------------------------------------
nace_lookup <- read_delim("data/nace_branchenavne.csv", delim = ";") |> 
  select(KODE, TITEL) |> 
  rename(Nace_kort = KODE, Branche_navn = TITEL)


# Tilføj branchebetegnelse baseret på Nacecode og fjern overflødige kolonner
# Lav en ny kolonne med de første to cifre af Nacecode
feature_engineering <- feature_engineering |> 
  mutate(Nace_kort = substr(Nacecode, 1, 2)) |> # Udtrækker de to første cifre
  select(-Nacebranche) |>                       # Fjerner den gamle kolonne
  left_join(nace_lookup, by = "Nace_kort") |>   # Slår op i brancheregister
  mutate(
    Branche_navn = replace_na(Branche_navn, "Ukendt"), 
    # Hvis ingen match, brug "Ukendt"
    Branche_navn = as.factor(Branche_navn) 
    # Gør den klar til ML (kategorisk)
  ) |> 
  select(-Nacecode, -Nace_kort) |>         # Fjerner unødvendige kolonner
  relocate(Branche_navn, .after = PNumber) # Flytter Branche_navn efter PNumber





# ------------------------------------------------------------------------------
# 4.6: Opretter 2. feature/variabel – har virksomheden haft kontakt?
# Vi kigger på flere kolonner og vurderer: 
# hvis mindst én ikke er "Tom", så har der været kontakt
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
    har_haft_kontakt = if_else(
      Virksomhedsbesøg != "Tom" | Telefonkontakt != "Tom" | 
        Konsulent_Navn != "Tom" | Notat != "Tom" | Kontaktdato != "Tom",
      "Ja", "Nej")
    ) |>  
  select(-Virksomhedsbesøg, -Telefonkontakt, - Konsulent_Navn, 
         -Notat, -Kontaktdato)

# ------------------------------------------------------------------------------
# 4.7: Opretter 3. feature/variabel – har virksomheden deltaget i event?
# Hvis EventLength er større end 0, siger vi "Ja", ellers "Nej"
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(deltaget_i_event = if_else(as.numeric(EventLength) > 0, "Ja", "Nej"))




# ------------------------------------------------------------------------------
# 4.8: Skaber kategorier der viser virksomhedens behov for hjælp
# Her grupperes TRUE/FALSE-kolonner i temaer som Strategi, Jura, Økonomi osv.
  # Den viser, hvilken overordnet type hjælp virksomheden har modtaget.
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  # Sørg for at konvertere kolonnerne til logiske værdier (TRUE/FALSE)
  mutate(across(matches("^\\d+_1"), ~ .x != "FALSE" & .x != "Tom")) |>
  mutate(
    
# Opretter en enkelt variabel, der kategoriserer virksomheden baseret på de 
    # 8 områder
    hjælp_kategori = case_when(

# Hvis virksomheden har søgt hjælp til strategi/emner som 
      # forretningsidé, produkt osv.
      (as.logical(Kundeportefølje) | as.logical(Forretningsmodel) | 
         as.logical(Forretningsidé) | as.logical(Produktportefølje)) 
      ~ "Strategi Udvikling",
      
# Hvis fokus har været på markedsføring, branding eller PR
      (as.logical(Markedsføring) | as.logical(Branding) | 
         as.logical(Kommunikation_og_PR)) ~ "Marketing og Kommunikation",

# Hvis der er søgt hjælp til salg, eksport eller markedsposition
      (as.logical(Salg) | as.logical(Eksport) | 
         as.logical(Markedsposition)) ~ "Salg og Eksport",
      
# Hvis der har været fokus på ledelse, netværk eller organisation
      (as.logical(Medarbejdere) | as.logical(Netværk) | 
         as.logical(Samarbejdspartnere) | as.logical(Ejer_og_bestyrelse)) 
                                            ~ "Organisation og Ledelse",
      
# Hvis det handler om økonomi, finansiering eller fonde
      (as.logical(Økonomistyring) | as.logical(Finansiering) | 
         as.logical(Kapitalfond) | as.logical(Vækstfonden) | 
         as.logical(Innovationsfonden)) ~ "Økonomi og Finansiering",
      
# Hvis det handler om daglig drift, it-systemer eller forretningsgange
      (as.logical(Leverance_og_projektstyring) | as.logical(IT_systemer) | 
         as.logical(Faciliteter) | 
         as.logical(Forretningsgange)) ~ "Drift og Systemer",
      
# Hvis fokus er på jura, ejerskifte mv.
      (as.logical(Juridiske_forhold) | 
         as.logical(Ejerskifte_og_generationsskifte)) ~ "Jura og Struktur",
    
# Hvis der er søgt støtte gennem offentlige ordninger
      (as.logical(EU_Kontoret_i_DK_Interreg) | as.logical(Erhvervshuset) | 
         as.logical(FN_1) | 
         as.logical(Andre_nationale_ordninger)) ~ "Støtteordninger",
      
      # Tilføjelse af de nye kategorier
      (as.logical(Uddannelse_kompetenceudvikling) | 
         as.logical(Vidensordninger) | 
         as.logical(IV_Vejledning) | 
         as.logical(Virksomhedsbesøg_Virksomhed_under_3_år) | 
         as.logical(I_Værkstedet) | 
         as.logical(Klippekort_Udleveret) | 
         as.logical(Væksthjul_Screening) | 
         as.logical(Agro_Business_Park) | 
         as.logical(Konsulent_virksomhed_uden_for_Kommunen_DK) | 
         as.logical(Lokal_konsulent_eller_virksomhed) | 
         as.logical(Indenrigsministeriet_The_Trade_Council) | 
         as.logical(Produktudviklin)) ~ "Andre Hjælpeordninger",
      
      TRUE ~ "Ingen specifik hjælp"
    )
  ) |>
  # Ryd op ved at fjerne de originale variabler der er brugt til grupperingen
  select(-c(
    Kundeportefølje, Forretningsmodel, Forretningsidé, Produktportefølje,
    Markedsføring, Branding, Kommunikation_og_PR,
    Salg, Eksport, Markedsposition,
    Medarbejdere, Netværk, Samarbejdspartnere, Ejer_og_bestyrelse,
    Økonomistyring, Finansiering, Kapitalfond, Vækstfonden, Innovationsfonden,
    Leverance_og_projektstyring, IT_systemer, Faciliteter, Forretningsgange,
    Juridiske_forhold, Ejerskifte_og_generationsskifte,
    EU_Kontoret_i_DK_Interreg, Erhvervshuset, FN_1, Andre_nationale_ordninger,
    Uddannelse_kompetenceudvikling, Vidensordninger, IV_Vejledning, 
    Virksomhedsbesøg_Virksomhed_under_3_år, I_Værkstedet, 
    Klippekort_Udleveret, Væksthjul_Screening, Agro_Business_Park, 
    Konsulent_virksomhed_uden_for_Kommunen_DK, Lokal_konsulent_eller_virksomhed, 
    Indenrigsministeriet_The_Trade_Council, Produktudviklin
  ))

# Tjek resultatet
glimpse(feature_engineering)


# ------------------------------------------------------------------------------
# 4.9: Behold kun aktive virksomheder
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |> 
  filter(CompanyStatus %in% c("Aktiv", "NORMAL")) |> 
  dplyr::select(-CompanyDateStamp, -CompanyId, -CVR, -Country, 
    -CompanyStatus, -AdvertisingProtected, -MaxParticipants, -Description,
    -EventLength, -EventId, -Andet) # Sletter de kolonner vi ikke vil bruge

# ------------------------------------------------------------------------------
# 4.10: Tilføj churn-kolonne
# Opretter ny kolonne kaldet 'churn',viser om virksomheden er stoppet som medlem. 
# Hvis BusinessCouncilMember er TRUE (virksomheden er medlem), sættes churn = 0
# Hvis BusinessCouncilMember er FALSE (virksomheden har forladt fællesskabet), 
# sættes churn = 1
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(churn = if_else(BusinessCouncilMember == TRUE, 0, 1)) |>
  select(-BusinessCouncilMember)

# ------------------------------------------------------------------------------
# 4.11: Konverter udvalgte kolonner til faktorer, 
# som er nødvendigt for ML-modeller
# En faktor er en kategorisk variabel – dvs. den indeholder en begrænset mængde 
# unikke værdier (kategorier). # Eksempler på faktorer: postnumre, ja/nej, 
# virksomhedsformer (ApS, A/S, IVS osv.)
# I maskinlæring skal sådanne kolonner være faktorer, 
# så algoritmerne forstår dem som kategorier og ikke som tekst.
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |> 
  mutate(
    CompanyTypeName = as.factor(CompanyTypeName),
    har_haft_kontakt = as.factor(har_haft_kontakt),
    deltaget_i_event = as.factor(deltaget_i_event),
    hjælp_kategori = as.factor(hjælp_kategori),
    PostalCode = as.factor(PostalCode),
    churn = as.factor(churn)
  )


# ------------------------------------------------------------------------------
# 4.12: Gem det færdigbehandlede datasæt til senere analyse eller modellering
# ------------------------------------------------------------------------------
write_rds(feature_engineering, "data/feature_engineered_data.rds")

```

5. EDA
```{r}
# EDA
```

6. Preprocessing
```{r}
set.seed(2025)

churn_split <- initial_split(feature_engineering, prop = 0.8, strata = churn)
churn_train <- training(churn_split)
churn_test  <- testing(churn_split)

churn_folds <- vfold_cv(churn_train, v = 10, strata = churn)

churn_recipe <- 
  recipe(churn ~ ., data = churn_train) |>
  step_novel(all_nominal_predictors()) |> 
  step_dummy(all_nominal_predictors(), one_hot = TRUE) |>
  step_zv(all_predictors()) |> 
  step_normalize(all_numeric_predictors()) |> 
  step_downsample(churn)  # Brug evt. step_smote(churn) hvis ekstrem ubalance
```

7. Modelling
```{r}
# Model specs
rf_spec <- rand_forest(mtry = tune(), min_n = tune()) |>
  set_engine("ranger", importance = "impurity") |>
  set_mode("classification")

xgb_spec <- boost_tree(trees = tune(), mtry = tune(), learn_rate = tune()) |>
  set_engine("xgboost") |>
  set_mode("classification")

log_reg_spec <- logistic_reg(penalty = tune(), mixture = tune()) |>
  set_engine("glmnet") |>
  set_mode("classification")

knn_spec <- nearest_neighbor(neighbors = tune(), weight_func = tune()) |>
  set_engine("kknn") |>
  set_mode("classification")

nb_spec <- naive_Bayes(smoothness = tune(), Laplace = tune()) |>
  set_engine("naivebayes") |>
  set_mode("classification")

svm_spec <- svm_rbf(cost = tune(), rbf_sigma = tune()) |>
  set_engine("kernlab") |>
  set_mode("classification")

# Samlet workflow set
churn_workflow_set <- workflow_set(
  preproc = list(churn_recipe = churn_recipe),
  models = list(
    rf = rf_spec,
    xgboost = xgb_spec,
    logistic = log_reg_spec,
    knn = knn_spec,
    naive_bayes = nb_spec,
    svm_rbf = svm_spec
  )
)
```

8. Evaluate metrics
```{r}
churn_metrics <- metric_set(accuracy, roc_auc, f_meas, sens, spec)

grid_ctrl <- control_grid(
  verbose = TRUE,
  save_pred = TRUE,
  parallel_over = "everything",
  save_workflow = TRUE
)

plan(multisession)
strt.time <- Sys.time()

# Man kører modellen - den står og arbejder
# Funktion der siger hvor langt modellen er nået i processen
churn_results <- churn_workflow_set |> 
  workflow_map(
    resamples = churn_folds,
    grid = 5,
    metrics = churn_metrics,
    control = grid_ctrl,
    seed = 2025
  )

Sys.time() - strt.time
plan(sequential)

# Sammenlign resultater
churn_results |> 
  rank_results(select_best = TRUE) |> 
  select(wflow_id, .metric, mean) |> 
  pivot_wider(names_from = .metric, values_from = mean) |> 
  arrange(-f_meas)

autoplot(churn_results, select_best = TRUE)
```

```{r}
# ------------------------------------------------------------------------------
# 10. Visualiseringer
# -------------------------------------------------------------------------
# Plot modeller efter deres performance
# -------------------------------------------------------------------------


# Din tibble, hvis ikke du allerede har den i en variabel:
metrics_df <- tibble::tibble(
  wflow_id = c("churn_recipe_rf", "churn_recipe_xgboost", "churn_recipe_svm_rbf",
               "churn_recipe_logistic", "churn_recipe_knn", "churn_recipe_naive_bayes"),
  accuracy = c(0.825, 0.827, 0.845, 0.807, 0.743, 0.710),
  f_meas   = c(0.724, 0.723, 0.708, 0.697, 0.592, 0.287),
  roc_auc  = c(0.877, 0.881, 0.439, 0.858, 0.778, 0.855),
  sens     = c(0.777, 0.766, 0.643, 0.755, 0.634, 0.272),
  spec     = c(0.845, 0.852, 0.929, 0.828, 0.788, 0.893)
)

# Gør labels lidt pænere
metrics_focus <- metrics_long %>%
  filter(metric %in% c("accuracy", "f_meas", "roc_auc")) %>%
  mutate(metric = case_when(
    metric == "accuracy" ~ "Accuracy",
    metric == "f_meas" ~ "F1-score",
    metric == "roc_auc" ~ "ROC AUC",
    TRUE ~ metric
  ))

# Nr. 1: BarPlot med værdier for denne 3 metrikker

ggplot(metrics_focus, aes(x = metric, y = value, fill = metric)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = round(value, 3)), vjust = -0.3, size = 3.5) +
  facet_wrap(~ wflow_id) +
  ylim(0, 1.05) +
  labs(
    title = "Model performance (Accuracy, F1 og ROC AUC)",
    x = NULL,
    y = "Score"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  ) +
  scale_fill_brewer(palette = "Set3")


# Nr. 2: Linje plot 

ggplot(metrics_focus, aes(x = wflow_id, y = value, color = metric, group = metric)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  geom_text(aes(label = round(value, 3)), vjust = -0.7, size = 3) +
  scale_color_brewer(palette = "Dark2") +
  labs(
    title = "Sammenligning på tværs af modeller",
    x = "Model",
    y = "Score"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5)
  )

# Nr. 3: Heatmap pr. model og metrik 

ggplot(metrics_focus, aes(x = metric, y = wflow_id, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), size = 3) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(
    title = "Performance heatmap pr. model og metrik",
    x = "Metric",
    y = "Model"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# -------------------------------------------------------------------------
# Plot for xgboost og Random forest med de vigtigste variabler 
# -------------------------------------------------------------------------

# Hent tuning-resultater for rf og xgboost
rf_result <- churn_results %>% extract_workflow_set_result("churn_recipe_rf")
xgb_result <- churn_results %>% extract_workflow_set_result("churn_recipe_xgboost")

# Hent workflow (før det er fit)
rf_workflow <- churn_results %>% extract_workflow("churn_recipe_rf")
xgb_workflow <- churn_results %>% extract_workflow("churn_recipe_xgboost")

# Vælg bedste parametre og fit modellen
best_rf <- rf_workflow %>%
  finalize_workflow(select_best(rf_result, metric = "f_meas")) %>%
  fit(data = churn_train)

best_xgb <- xgb_workflow %>%
  finalize_workflow(select_best(xgb_result, metric = "f_meas")) %>%
  fit(data = churn_train)

# Feature importance
vip_rf <- vi(extract_fit_parsnip(best_rf)) %>% mutate(model = "Random Forest")
vip_xgb <- vi(extract_fit_parsnip(best_xgb)) %>% mutate(model = "XGBoost")

# Kombinér og vis kun top 10 vigtigste variabler pr. model
vip_combined <- bind_rows(vip_rf, vip_xgb) %>%
  group_by(model) %>%
  slice_max(order_by = Importance, n = 10) %>%
  ungroup() %>%
  mutate(Variable = str_wrap(Variable, width = 25))

# Plot med labels og tekstrotation optimeret
ggplot(vip_combined, aes(x = reorder(Variable, Importance), y = Importance, fill = model)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = round(Importance, 2)), hjust = -0.1, size = 3) +
  facet_wrap(~ model, scales = "free") +
  coord_flip() +
  labs(
    title = "Top 10 vigtigste variabler pr. model",
    x = "Variabel",
    y = "Vigtighed"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.y = element_text(size = 9)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) #ektra space til labels
# ------------------------------------------------------------------------------
```

```{r}
# ------------------------------------------------------------------------------
# 11. Evaluering af bedste model på testdatasættet (Random Forest) 

# Hvis XGBoost skal vi prøve med flere grids først for at teste den bedre
# ------------------------------------------------------------------------------

# 1. Find bedste parametre for den bedste model
best_results <- churn_results |> 
  extract_workflow_set_result("churn_recipe_rf") |> 
  select_best(metric = "f_meas")

# 2. Finaliser workflow med de fundne parametre
final_wf <- churn_results |> 
  extract_workflow("churn_recipe_rf") |> 
  finalize_workflow(best_results)

# 3. Træn modellen på træningsdata og evaluer på testdata
churn_last_fit <- final_wf |> 
  last_fit(split = churn_split, metrics = churn_metrics)

# 4. Udskriv evalueringsmetrikker
collect_metrics(churn_last_fit)

# 5. Gem confusion matrix som objekt (brugbar til præsentation)
conf_matrix <- churn_last_fit |> 
  collect_predictions() |> 
  conf_mat(estimate = .pred_class, truth = churn)

# 6. Gem test-prædiktioner hvis ønsket
test_preds <- collect_predictions(churn_last_fit)

# 7. Træn endelig model på hele datasættet
final_model <- fit(final_wf, data = feature_engineering)

# 8. Gem modellen
saveRDS(final_model, "final_churn_model.rds")


# ------------------------------------------------------------------------------
# 11.1 Eksempel: Forudsig churn for én ny virksomhed
# ------------------------------------------------------------------------------

new_company <- tibble(
  Employees = 15,
  PostalCode = factor("8800"),
  CompanyTypeName = factor("Aktieselskab"),
  har_haft_kontakt = factor("Ja"),
  deltaget_i_event = factor("Nej"),
  hjælp_kategori = factor("Strategi Udvikling"),
  medlem_antal_år = 2,
  Branche_navn = factor("Fremstilling af maskiner og udstyr i.a.n."),
  MeetingLength = 180,
  PNumber = 12345678
)

# Forudsiger klassifikation og sandsynlighed
predict(final_model, new_company)                    # 0 = bliver, 1 = churn
predict(final_model, new_company, type = "prob")     # churn-sandsynlighed


# ------------------------------------------------------------------------------
# 11.2 Forudsig churn for ALLE virksomheder og tilføj resultater
# ------------------------------------------------------------------------------

# Forudsiger sandsynlighed og klasse
churn_probs   <- predict(final_model, feature_engineering, type = "prob")
churn_classes <- predict(final_model, feature_engineering)

# Kombiner og omdøb kolonner
all_predictions <- bind_cols(churn_probs, churn_classes) |> 
  rename(
    churn_prob = .pred_1,      # Sandsynlighed for churn
    churn_class = .pred_class  # Klassifikation (0/1)
  )

# Tilføj til datasættet og konvertér sandsynlighed til procent
full_results <- feature_engineering |> 
  bind_cols(all_predictions) |> 
  mutate(
    churn_prob = round(churn_prob * 100, 1)
  )

# Tilføj churn-risikokategorier tidligt (bruges i visualiseringer og rapporter)
full_results <- full_results |> 
  mutate(
    churn_risiko = case_when(
      churn_prob >= 80 ~ "Høj risiko",
      churn_prob >= 60 ~ "Moderat risiko",
      churn_prob >= 40 ~ "Lav risiko",
      TRUE             ~ "Minimal risiko"
    )
  )


# ------------------------------------------------------------------------------
# 11.3 Churn-risiko: Filtrér medlemmer (churn == 0) med høj risiko (churn_class == 1)
# ------------------------------------------------------------------------------

top_risiko_medlemmer <- full_results |> 
  filter(churn == 0, churn_class == 1) |> 
  arrange(desc(churn_prob)) |> 
  slice_head(n = 20)  # Call to action: top 20

View(top_risiko_medlemmer)


# ------------------------------------------------------------------------------
# 11.4 Visualiseringer: Brancher og postnumre med høj churn
# ------------------------------------------------------------------------------

# Brancher med højest gennemsnitlig churn
full_results |> 
  group_by(Branche_navn) |> 
  summarise(gennemsnitlig_churn = mean(churn_prob), n = n()) |> 
  arrange(desc(gennemsnitlig_churn)) |> 
  slice_head(n = 5) |> 
  ggplot(aes(x = reorder(Branche_navn, gennemsnitlig_churn), y = gennemsnitlig_churn)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 5 brancher med højest churn-risiko", x = "Branche", y = "Gns. churn sandsynlighed (%)") +
  theme_minimal()

# Postnumre med højest gennemsnitlig churn
full_results |> 
  group_by(PostalCode) |> 
  summarise(gennemsnitlig_churn = mean(churn_prob), n = n()) |> 
  arrange(desc(gennemsnitlig_churn)) |> 
  slice_head(n = 5) |> 
  ggplot(aes(x = reorder(as.character(PostalCode), gennemsnitlig_churn), y = gennemsnitlig_churn)) +
  geom_col(fill = "darkred") +
  coord_flip() +
  labs(title = "Top 5 postnumre med højest churn-risiko", x = "Postnummer", y = "Gns. churn sandsynlighed (%)") +
  theme_minimal()


# ------------------------------------------------------------------------------
# 11.5 Hvad kendetegner virksomheder der IKKE churner?
# ------------------------------------------------------------------------------

full_results |> 
  filter(churn_class == 0) |>  # Virksomheder som modellen forudser bliver
  count(Branche_navn, sort = TRUE) |> 
  slice_head(n = 5) |> 
  ggplot(aes(x = reorder(Branche_navn, n), y = n)) +
  geom_col(fill = "forestgreen") +
  coord_flip() +
  labs(
    title = "Top 5 brancher hvor virksomheder ikke churner",
    x = "Branche",
    y = "Antal virksomheder"
  ) +
  theme_minimal()

# Sammenlignende statistik på udvalgte variabler
# churn_class:
# 0 = modellen tror de bliver
# 1 = modellen tror de churner
full_results |> 
  group_by(churn_class) |> 
  summarise(
    mødelængde = mean(MeetingLength),
    medlem_år = mean(medlem_antal_år),
    kontakt_rate = mean(har_haft_kontakt == "Ja"),
    event_rate = mean(deltaget_i_event == "Ja")
  )


# -------------------------------------------------------------------------
# Forklaring af churn-relaterede variabler
# -------------------------------------------------------------------------

# 1. churn:
#    Den faktiske status for virksomheden ifølge databasen.
#    0 = Virksomheden er stadig medlem.
#    1 = Virksomheden har meldt sig ud (churnet).
#    Dette er det "rigtige facit", vi forsøger at forudsige.

# 2. .pred_0:
#    Modellens vurdering af sandsynligheden for, at virksomheden IKKE churner.
#    Fx 0.93 betyder: modellen mener der er 93 % chance for, at virksomheden bliver medlem.
#    OBS: Denne bruges mest til teknisk forståelse – i praksis bruger vi oftest churn_prob i stedet.

# 3. churn_prob:
#    Modellens vurdering af sandsynligheden for churn – konverteret til procent.
#    Fx 6.1 betyder: modellen vurderer, at der er 6,1 % risiko for, at virksomheden churner.
#    Denne kolonne er lettest at forstå og bruge i praksis.

# 4. churn_class:
#    Modellens endelige beslutning: churn eller ej?
#    1 = modellen tror virksomheden churner
#    0 = modellen tror virksomheden bliver
#    Beslutningen bygger på en tærskel, typisk 50 %

# 5. churn_risiko:
#    Kategori baseret på churn_prob – lavet for at gøre det endnu mere overskueligt.
#    Fx:
#      • "Minimal risiko" → under 40 %
#      • "Lav risiko"     → 40-59 %
#      • "Moderat risiko" → 60-79 %
#      • "Høj risiko"     → 80 % eller højere
```

