---
title: ""
subtitle: ""

date: "09-05-2025"
author:
  - "Line A. Adolph"
  - "Maria B. A. Hitz"
  - "Maria Cristiana Maxim"
  - "Martin E. Bindner"
  - "Abdikadir A. M. H. Omar"
  
format: 
  pdf:
    toc: false
    toc-title: Indholdsfortegnelse
    toc-depth: 4
    number-sections: true
    number-depth: 4
    fontsize: 12pt
    mainfont: Times New Roman
    linestretch: 1.5
    geometry:
      - top=30mm
      - left=20mm
      - right=20mm
      - bottom=30mm
      - heightrounded
---

\renewcommand{\contentsname}{Indholdsfortegnelse}
\newpage

```{r}
#| label: setup
#| include: false
#| warning: false
#| 

# eval: false prevents code from being evaluated. (And obviously if the code is not run, no results will be generated). This is useful for displaying example code, or for disabling a large block of code without commenting each line.

# include: false runs the code, but doesn’t show the code or results in the final document. Use this for setup code that you don’t want cluttering your report.

# echo: false prevents code, but not the results from appearing in the finished file. Use this when writing reports aimed at people who don’t want to see the underlying R code.

# Du kan lave code chunks med crtl/alt/I. 
# Angiv en label som ovenfor til hver chunk. 
# Brug evt. include, eval, echo eller en anden parameter til at få det ønskede output

pacman::p_load(
    dplyr,         # til datamanipulation
    tidyr,         # til fx split af kolonner
    stringr,        # til teksthåndtering
    tidyverse,     # samlet pakke til dataanalyse (inkl. ggplot2, tibble, mm.)
    skimr,         # oversigtsstatistik
    readxl,        # læsning af Excel-filer
    hms,           # håndtering af tid
    ggpubr,        # ggplot med publikationstema
    ggfortify,     # autoplot til modeller
    GGally,        # udvidelse af ggplot, fx ggpairs
    gridExtra,     # arrangering af plots
    hrbrthemes,    # moderne ggplot-temaer
    table1,        # flot tabel 1 output
    tidymodels,    # samlet ML-framework
    themis,        # håndtering af ubalancerede data
    broom,         # konvertering af modeller til tidy-format
    caret,         # klassisk ML-framework
    discrim,       # diskriminantanalyse
    glmnet,        # regulerede regressioner
    kknn,          # k-NN klassifikation/regression
    naivebayes,    # naive bayes modeller
    kernlab,       # kernelbaserede metoder inkl. SVM
    xgboost,       # gradient boosting
    ranger,        # hurtig random forest
    gbm,           # gradient boosting machines
    randomForest,  # klassisk random forest
    rpart,         # beslutningstræer
    leaps,         # modelselektionsmetoder
    car,           # diagnostik for lineære modeller
    PerformanceAnalytics, # performance-metrics (især finans)
    rvest,         # web scraping
    httr,          # HTTP requests
    jsonlite,      # arbejde med JSON
    rjson,         # alternativ JSON-pakke
    rlist,         # listehåndtering
    Rcrawler,      # web crawling
    rmarkdown,     # rapportgenerering
    knitr,         # knit Rmd-dokumenter
    future         # parallelisering og asynkron kodning
    
)
```

\begin{titlepage}
\begin{center}

\includegraphics[width=18cm]{images/churn_cover.png}

\vspace{0.5cm}

{\large \textbf{Forfattere:}}\\
Line A. Adolph, Maria B. A. Hitz, Maria Cristiana Maxim, Martin Bindner, Abdikadir A. M. H. Omar

\vspace{0.5cm}

{\large \textbf{1. interne eksamensprojekt}} \\
Vejleder: Simon Bjerrum Eilersen

\vspace{0.5cm}

{\large \textbf{Dato: 9. maj 2025}}

\vfill

{\large \textbf{Antal tegn: xx.xxx}}

\end{center}
\end{titlepage}

\newpage

\tableofcontents
\newpage

# Resumé

# Indledning

Business Viborg er registreret under branchekoden 26104793, og arbejder målrettet for at skabe optimale rammer for erhvervslivet i Viborg Kommune. Som en medlemsorganisation med over 600 virksomheder i ryggen, er relationerne til medlemskredsen helt afgørende, både for at dele viden, styrke netværk og skabe lokal vækst.I forbindelse med præsentationen af Business Viborg udtalte chefkonsulent Michael Freundlich: “Vores mål for 2025 er at nå 700 medlemmer og en omsætning på 2,9 mio. kr.”

Men når virksomheder melder sig ud, mister Business Viborg ikke kun en indtægt, men også værdifulde forbindelser, politisk legitimitet og mulighed for at gøre en forskel for erhvervslivet i området. For at handle proaktivt ønsker Business Viborg at få bedre indsigt i, hvad der driver churn og hvem der er i risikozonen. 

Derfor skal der udvikles et datadrevet værktøj, som kombinerer teknisk analyse med brugervenlig indsigt. Et værktøj, der gør det muligt for både medlemskonsulenter og ledelse at træffe kloge beslutninger og handle i tide med respekt for både dataetik og jura.


# Problemformulering

Hvordan kan Business Viborg analysere og anvende medlemsdata til at udvikle et beslutningsunderstøttende dashboard, der forudsiger churn og forklarer centrale risikofaktorer baseret på relevante maskinlæringsmetoder og med inddragelse af etiske og juridiske overvejelser?

## Underspørgsmål

**Eksplorativ analyse (EDA)**

Beskriv hvilke mønstre og karakteristika kendetegner de virksomheder, der forlader Business Viborg?

**Modelvalg og performance**

Hvordan kan forskellige machine learning-modeller anvendes til at forudsige churn i Business Viborgs kontekst, og hvilke modeller er mest velegnede?

**Datavisualisering**

Hvordan kan resultater og churn-indsigter formidles via et brugervenligt dashboard, som understøtter daglig opsøgende indsats for medlemskonsulenter og ledelse?

**Etik og jura**

Hvilke juridiske krav (fx GDPR) og etiske overvejelser bør indgå i udviklingen og brugen af et churn-forudsigelsesværktøj baseret på medlemsdata?


# Afgrænsning

## AI Chatbots
I forbindelse med udarbejdelsen af projektet er ChatGPT 4.0 blevet anvendt som et værktøj til grammatisk og sproglig korrektur, idéudvikling samt forbedring af det sproglige udtryk. Modellen har udelukkende fungeret som et hjælpemiddel i arbejdet med tekstbaserede opgaver og har hverken erstattet selvstændig analyse, kritisk refleksion eller været brugt til direkte besvarelse af problemformuleringen

I dette projekt fokuserer vi på at udvikle en webbaseret applikation, der kan forudsige medlems-churn og visualisere centrale churn-drivere for Business Viborg. Projektet indebærer derfor flere afgrænsninger.

## Data
Vi anvender udelukkende datasættet, som er udleveret af Business Viborg. Datasættet indeholder information om medlemskab, virksomhedsstørrelse, branche, engagementsniveau, kontaktfrekvens og deltagelse i arrangementer. Dataene er anonymiserede og begrænset til et specifikt tidsrum, hvilket kan påvirke modellens generaliserbarhed.

## Modeller
Projektet fokuserer på udvikling og afprøvning af machine learning-modeller til churn-prediktion, herunder blandt andet Random Forest, XGBoost og Lasso. Vi anvender bootstrapping som resampling-metode og benytter AUC og accuracy som de primære evalueringsmål. Fokus er på modellens forklaringskraft og praktiske anvendelighed frem for at optimere for den højest mulige præcision.

## Webapplikation
Applikationen er en prototype og er ikke integreret med Business Viborgs IT-systemer eller databaser. Den kan uploades og anvendes lokalt eller via RStudio Cloud.

## Etik og jura
Vi behandler kort de etiske og juridiske aspekter ved brugen af persondata i overensstemmelse med GDPR, men foretager ikke en fuld juridisk gennemgang. Implementering af samtykke- og adgangsstyring indgår ikke som en del af denne prototype.


# Definitioner

# Analyse

# Anbefaling

# Konklusion

# 

\newpage

# Literaturliste

**AI**

OpenAI. (2025). ChatGPT (4.0). <https://chatgpt.com/>

**Bøger**

**WWW-dokumenter**

**Undervisningsmaterialer**

\newpage

# Bilagsoversigt

-   Bilag 1: x
-   Bilag 2: x
-   Bilag 3: x
-   Bilag 4: x
-   Bilag 5: x
-   Bilag 6: x

\newpage
Pacman
```{r}
# ------------------------------------------------------------------------------
# Pacman
# ------------------------------------------------------------------------------
pacman::p_load(
  dplyr, 
  tidyr, 
  stringr, 
  tidyverse, 
  skimr, 
  readxl, 
  hms, 
  ggpubr,
  ggfortify, 
  GGally, 
  gridExtra, 
  hrbrthemes, 
  table1, 
  tidymodels, 
  themis,
  broom, 
  caret, 
  discrim, 
  glmnet, 
  kknn, 
  naivebayes, 
  kernlab, 
  xgboost,
  ranger, 
  gbm, 
  randomForest, 
  rpart, 
  leaps, 
  car, 
  PerformanceAnalytics,
  rvest, 
  httr, 
  jsonlite, 
  rjson, 
  rlist, 
  Rcrawler, 
  rmarkdown, 
  knitr, 
  future
)
```

1. Data load
```{r}
# ------------------------------------------------------------------------------
# 1. Load data
# ------------------------------------------------------------------------------

# Indlæser alle nødvendige datasæt
meetings <- readRDS("data/meetings.rds")
events <- readRDS("data/events.rds")
event_participants <- readRDS("data/event_participants.rds")
company_contacts <- readRDS("data/company_contacts.rds")
all_contact <- readRDS("data/all_contact.rds")
all_companies <- readRDS("data/all_companies.rds")
old_projects <- readRDS("data/old_projects.rds")

```


2. Merge datasets
```{r}
# ------------------------------------------------------------------------------
# 2.1: Fjern dubletter og behold første registrering pr. virksomhed
# ------------------------------------------------------------------------------
meetings_unique <- meetings |>
  group_by(CompanyId) |> 
  summarise(across(everything(), first))    # Første møde pr. virksomhed

events_unique <- events |>
  group_by(Cvr) |> 
  summarise(across(everything(), first))    # Første event pr. virksomhed

event_participants_unique <- event_participants |>
  group_by(Cvr) |> 
  summarise(across(everything(), first))    # Første deltagerinfo pr. virksomhed



# ------------------------------------------------------------------------------
# 2.2: Saml alle datasæt med left_join og ryd op i dubletter
# ------------------------------------------------------------------------------
merged_df <- all_companies |> 
  left_join(company_contacts, by = "CompanyId") |>     # Join kontaktpersoner
  left_join(all_contact, by = "contactId") |>          # Join kontaktinfo
  left_join(meetings_unique, by = "CompanyId") |>      # Join mødedata
  rename(Cvr = "z_companies_1_CVR-nummer_1") |>        # Omdøber kolonnen til 
                                              # "Cvr", så den matcher med events
  left_join(events_unique, by = "Cvr") |>              # Join eventinfo
  left_join(event_participants_unique, by = "Cvr") |>  # Join deltagerinfo
  select(-ends_with(".y"), -ends_with(".x"))           # Fjerner dublet-kolonner


# ------------------------------------------------------------------------------
# 2.3: Klargør datasæt: fjern anonyme oplysninger og omdøb kolonnenavne
# ------------------------------------------------------------------------------
# Viser overblik over datasættet og datatyper
glimpse(merged_df)

# Fokus: Unikke virksomheder via PNumber (produktionsenhedsnummer)
# Det giver os 2966 unikke observationer.
merged_df <- merged_df |> 
  select(-z_companies_1_Firmanavn_1, -z_contacts_1_Email_1)  
# Fjerner anonymiserede data

# Standardiser kolonnenavne for overskuelighed
colnames(merged_df) <- c(
  "BusinessCouncilMember", "CompanyDateStamp", "CompanyId", "CompanyType",
  "CVR", "Employees", "PostalCode", "CompanyTypeName", "PNumber", "Country",
  "NACECode", "CompanyStatus", "AdvertisingProtected", "ContactId",
  "CompanyOwnerId", "ContactLastUpdated", "TitleChanged", "LocationChanged",
  "CreatedBy", "MeetingLength", "Firstname", "UserRole", "Initials",
  "EventExternalId", "EventPublicId", "Description", "LocationId",
  "MaxParticipants", "EventLength", "EventId"
)

# ------------------------------------------------------------------------------
# 2.4: Fjern dubletter og irrelevante kolonner
# Udfyld manglende værdier i eventkolonner med "Ingen event"
# ------------------------------------------------------------------------------

# Beholder unikke virksomheder, fjerner irrelevante kolonner,
# og udfylder NA i eventdata
merged_unique <- merged_df |>
  distinct(PNumber, .keep_all = TRUE) |>  # Beholder én række pr. PNumber
  select(-TitleChanged, -LocationChanged, -CreatedBy, -Firstname,  
         # Fjerner irrelevante variabler
         -UserRole, -Initials, -ContactLastUpdated) |>
  mutate(across(  # Erstatter NA i event-kolonner med "Ingen event"
    c(MeetingLength, EventExternalId, EventPublicId, Description, 
      LocationId, MaxParticipants, EventLength, EventId),
    ~ if_else(is.na(.), "Ingen event", as.character(.))
  ))

# Rens MeetingLength og konverter til numerisk (fjern " mins")
merged_unique <- merged_unique |> 
  mutate(
    MeetingLength = ifelse(MeetingLength == "Ingen event", "0 mins", 
                           MeetingLength), 
    MeetingLength = as.numeric(str_remove(MeetingLength, " mins"))
  )
  
# ------------------------------------------------------------------------------
# 2.5: Splitter NACECode i kode og beskrivelse, 
# fjern original kolonne og NA-rækker
# ------------------------------------------------------------------------------
merged_unique <- merged_unique |>
  mutate(
    Employees   = if_else(is.na(Employees), "Ukendt", as.character(Employees)),
    # NA -> "Ukendt"
    
    NACECode    = if_else(is.na(NACECode),  "Ukendt", as.character(NACECode)),
    # NA -> "Ukendt"
    
    Nacecode    = if_else(NACECode == "Ukendt", "Ukendt", 
                          str_extract(NACECode, "^[0-9]+")),                 
    # Hent kode
    Nacebranche = if_else(NACECode == "Ukendt", "Ukendt", 
                          str_remove(NACECode, "^[0-9]+\\s*"))               
    # Hent branche
  ) |>
  select(-NACECode) |>  # Fjerner original NACECode-kolonne
  na.omit()             # Fjerner rækker med NA-værdier

# ------------------------------------------------------------------------------
# 2.6: Tjek for tilbageværende NA-værdier
# ------------------------------------------------------------------------------
colSums(is.na(merged_unique))


# ------------------------------------------------------------------------------
# 2.7: Gem det rensede datasæt til senere brug
# ------------------------------------------------------------------------------
saveRDS(merged_unique, "merged_unique.rds")

# ------------------------------------------------------------------------------
# 2.8: Merge old_projects (frivillig) med virksomhedsdata
# ------------------------------------------------------------------------------

# Omdøb SMVContactId til ContactId
old_projects <- old_projects |>
  rename(ContactId = SMVContactId) # Omdøb kolonne for at matche join

# Gem kolonnenavne fra old_projects (ekskl. ContactId)
old_project_cols <- setdiff(names(old_projects), "ContactId")
cols_to_fill <- setdiff(old_project_cols, c("Id", "SMVCompanyId", "SharedWith"))

# Join med merged_unique og erstat NA med "Tom"
merged_unique_old_projects <- merged_unique |>
  left_join(old_projects, by = "ContactId") |>   # Merger på ContactId
  select(-Id, -SMVCompanyId, -SharedWith) |>     # Fjerner unødvendige kolonner
  mutate(across(all_of(cols_to_fill), 
                ~ if_else(is.na(.), "Tom", as.character(.)))) |> # NA → "Tom"
  distinct(PNumber, .keep_all = TRUE)            # Behold unikke virksomheder

# ------------------------------------------------------------------------------
# 2.9: Tjek for NA-værdier i det udvidede datasæt
# ------------------------------------------------------------------------------
colSums(is.na(merged_unique_old_projects))

merge_datasets <- merged_unique_old_projects
```

3. Clean data
```{r}
# ------------------------------------------------------------------------------
# 3.1: Første kig på datastrukturen
# Giver et hurtigt overblik over variabelnavne, typer og eksempelværdier
# ------------------------------------------------------------------------------
glimpse(merge_datasets)



# ------------------------------------------------------------------------------
# 3.2: Tæl hvor mange NA (manglende værdier) der findes i hver kolonne
# Dette er nyttigt for at forstå, hvor der evt. skal renses eller imputeres
# ------------------------------------------------------------------------------
# Tjekker for manglende værdier (NA) i alle variabler
na_count <- merge_datasets |> 
  summarise(across(everything(), ~ sum(is.na(.)))) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "na_count")

# ------------------------------------------------------------------------------
# 3.3: Rensning af kolonnenavne
# Fjerner forstyrrende elementer som tal, specialtegn og mellemrum
# Gør kolonnenavne nemmere at bruge i videre analyser og modeller
# ------------------------------------------------------------------------------
# Rydder op i variabelnavne: fjerner tal, specialtegn og whitespace
names(merge_datasets) <- names(merge_datasets) |>
  str_remove("^[0-9]+_1*\\s*") |>     # Fjerner startende tal/1-taller
  str_replace_all("[ /\\-]+", "_") |> # Erstatter mellemrum og specialtegn med _
  str_replace_all("_+", "_") |>       # Fjerner dobbelte underscores
  str_remove("_$") |>                 # Fjerner underscore i slutningen
  str_trim()                          # Trim whitespace

# Udskriver de rensede kolonnenavne
print(names(merge_datasets))

# ------------------------------------------------------------------------------
# 3.4: Fjern irrelevante kolonner (ID’er og tekniske felter)
# Disse kolonner bruges ikke i analysen og fjernes derfor fra datasættet
# ------------------------------------------------------------------------------
clean_data <- merge_datasets |> 
  dplyr::select(-ContactId, -CompanyOwnerId, -EventExternalId,
                -EventPublicId, -LocationId, -Tekstfelt, -CompanyType)

# ------------------------------------------------------------------------------
# 3.5: Erstatning og konvertering af værdier
# - Tekst som "Tom", "Ukendt" og "Ingen event" → NA
# - NA i tekstfelter bliver til "Ukendt"
# - NA i tal bliver til 0
# - Udvalgte kolonner konverteres til numerisk format
# ------------------------------------------------------------------------------
clean_data <- clean_data |>
  mutate(
    across(
      c(CVR, Nacecode, PostalCode, PNumber, MaxParticipants, 
        EventLength, Employees), ~ as.numeric(ifelse(.x %in% c(" ", "", "Tom", 
                                            "Ukendt", "Ingen event"), NA, .x))
    ),
    across(where(is.character), ~ replace_na(.x, "Ukendt")), # Tekst: NA → 
    # "Ukendt"
    across(where(is.numeric), ~ replace_na(.x, 0))             # Tal: NA → 0
  )

# ------------------------------------------------------------------------------
# 3.6: Konverter dato-kolonner til rigtig datoformat
# Vigtigt hvis man senere skal beregne fx forskel i tid
# ------------------------------------------------------------------------------
CompanyDateStamp <- as.Date(clean_data$CompanyDateStamp, format = "%Y-%m-%d")
Kontaktdato      <- as.Date(clean_data$Kontaktdato, format = "%Y-%m-%d")




# ------------------------------------------------------------------------------
# 3.7: # Viser datastruktur efter rensning
# ------------------------------------------------------------------------------
glimpse(clean_data)
```

4. Feature Engineering
```{r}

# ------------------------------------------------------------------------------
# 4.1: # Viser datastruktur efter rensning
# ------------------------------------------------------------------------------

glimpse(clean_data) # Bruger glimpse til at få et hurtigt overblik over data


# ------------------------------------------------------------------------------
# 4.2: Opretter en ny variabel, der beregner hvor mange år 
# en virksomhed har været medlem. Vi bruger CompanyDateStamp (oprettelsesdato)
# og beregner forskellen til dags dato.
# ------------------------------------------------------------------------------
feature_engineering <- clean_data |>
  mutate(
    medlem_antal_år = round(
      as.numeric(difftime(Sys.Date(), as.Date(CompanyDateStamp), 
                          units = "days")) / 365, 
      0
    )
  )
  

# ------------------------------------------------------------------------------
# 4.3: Rensning af Employees-kolonnen (antal ansatte). 
# Nogle gange kan tal være formateret med punktummer (f.eks. "1.000") 
# eller mellemrum (f.eks. "1 000"). 
# Disse fjernes, så kolonnen kan konverteres til numerisk format
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
    Employees = Employees |> 
      str_replace_all("\\.", "") |>       # Fjerner punktummer
      str_replace_all("\\s+", "") |>      # Fjerner mellemrum
      as.numeric()                        # Konverterer til tal
  )

# ------------------------------------------------------------------------------
# 4.4: Oversættelse af virksomhedstyper til mere læsbare formater
# Eksempel: "A/S" bliver til "Aktieselskab"
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
CompanyTypeName = str_replace_all(CompanyTypeName, "A/S", "Aktieselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "ApS", "Anpartsselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "IVS", "Iværksætterselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "P/S", "Partnerselskab"),
CompanyTypeName = str_replace_all(CompanyTypeName, "K/S", "Kommanditselskab")
  )

# ------------------------------------------------------------------------------
# 4.5: Tilføj branchebetegnelse baseret på NACE-koder
# NACE er en standard for brancheklassifikation (fx "01 Landbrug")
# Vi bruger de første to cifre til at matche mod en lookup-tabel med branchenavne
# ------------------------------------------------------------------------------
nace_lookup <- read_delim("data/nace_branchenavne.csv", delim = ";") |> 
  select(KODE, TITEL) |> 
  rename(Nace_kort = KODE, Branche_navn = TITEL)


# Tilføj branchebetegnelse baseret på Nacecode og fjern overflødige kolonner
# Lav en ny kolonne med de første to cifre af Nacecode
feature_engineering <- feature_engineering |> 
  mutate(Nace_kort = substr(Nacecode, 1, 2)) |> # Udtrækker de to første cifre
  select(-Nacebranche) |>                       # Fjerner den gamle kolonne
  left_join(nace_lookup, by = "Nace_kort") |>   # Slår op i brancheregister
  mutate(
    Branche_navn = replace_na(Branche_navn, "Ukendt"), 
    # Hvis ingen match, brug "Ukendt"
    Branche_navn = as.factor(Branche_navn) 
    # Gør den klar til ML (kategorisk)
  ) |> 
  select(-Nacecode, -Nace_kort) |>         # Fjerner unødvendige kolonner
  relocate(Branche_navn, .after = PNumber) # Flytter Branche_navn efter PNumber





# ------------------------------------------------------------------------------
# 4.6: Opretter 2. feature/variabel – har virksomheden haft kontakt?
# Vi kigger på flere kolonner og vurderer: 
# hvis mindst én ikke er "Tom", så har der været kontakt
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(
    har_haft_kontakt = if_else(
      Virksomhedsbesøg != "Tom" | Telefonkontakt != "Tom" | 
        Konsulent_Navn != "Tom" | Notat != "Tom" | Kontaktdato != "Tom",
      "Ja", "Nej")
    ) |>  
  select(-Virksomhedsbesøg, -Telefonkontakt, - Konsulent_Navn, 
         -Notat, -Kontaktdato)

# ------------------------------------------------------------------------------
# 4.7: Opretter 3. feature/variabel – har virksomheden deltaget i event?
# Hvis EventLength er større end 0, siger vi "Ja", ellers "Nej"
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(deltaget_i_event = if_else(as.numeric(EventLength) > 0, "Ja", "Nej"))




# ------------------------------------------------------------------------------
# 4.8: Skaber kategorier der viser virksomhedens behov for hjælp
# Her grupperes TRUE/FALSE-kolonner i temaer som Strategi, Jura, Økonomi osv.
  # Den viser, hvilken overordnet type hjælp virksomheden har modtaget.
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  # Sørg for at konvertere kolonnerne til logiske værdier (TRUE/FALSE)
  mutate(across(matches("^\\d+_1"), ~ .x != "FALSE" & .x != "Tom")) |>
  mutate(
    
# Opretter en enkelt variabel, der kategoriserer virksomheden baseret på de 
    # 8 områder
    hjælp_kategori = case_when(

# Hvis virksomheden har søgt hjælp til strategi/emner som 
      # forretningsidé, produkt osv.
      (as.logical(Kundeportefølje) | as.logical(Forretningsmodel) | 
         as.logical(Forretningsidé) | as.logical(Produktportefølje)) 
      ~ "Strategi Udvikling",
      
# Hvis fokus har været på markedsføring, branding eller PR
      (as.logical(Markedsføring) | as.logical(Branding) | 
         as.logical(Kommunikation_og_PR)) ~ "Marketing og Kommunikation",

# Hvis der er søgt hjælp til salg, eksport eller markedsposition
      (as.logical(Salg) | as.logical(Eksport) | 
         as.logical(Markedsposition)) ~ "Salg og Eksport",
      
# Hvis der har været fokus på ledelse, netværk eller organisation
      (as.logical(Medarbejdere) | as.logical(Netværk) | 
         as.logical(Samarbejdspartnere) | as.logical(Ejer_og_bestyrelse)) 
                                            ~ "Organisation og Ledelse",
      
# Hvis det handler om økonomi, finansiering eller fonde
      (as.logical(Økonomistyring) | as.logical(Finansiering) | 
         as.logical(Kapitalfond) | as.logical(Vækstfonden) | 
         as.logical(Innovationsfonden)) ~ "Økonomi og Finansiering",
      
# Hvis det handler om daglig drift, it-systemer eller forretningsgange
      (as.logical(Leverance_og_projektstyring) | as.logical(IT_systemer) | 
         as.logical(Faciliteter) | 
         as.logical(Forretningsgange)) ~ "Drift og Systemer",
      
# Hvis fokus er på jura, ejerskifte mv.
      (as.logical(Juridiske_forhold) | 
         as.logical(Ejerskifte_og_generationsskifte)) ~ "Jura og Struktur",
    
# Hvis der er søgt støtte gennem offentlige ordninger
      (as.logical(EU_Kontoret_i_DK_Interreg) | as.logical(Erhvervshuset) | 
         as.logical(FN_1) | 
         as.logical(Andre_nationale_ordninger)) ~ "Støtteordninger",
      
      # Tilføjelse af de nye kategorier
      (as.logical(Uddannelse_kompetenceudvikling) | 
         as.logical(Vidensordninger) | 
         as.logical(IV_Vejledning) | 
         as.logical(Virksomhedsbesøg_Virksomhed_under_3_år) | 
         as.logical(I_Værkstedet) | 
         as.logical(Klippekort_Udleveret) | 
         as.logical(Væksthjul_Screening) | 
         as.logical(Agro_Business_Park) | 
         as.logical(Konsulent_virksomhed_uden_for_Kommunen_DK) | 
         as.logical(Lokal_konsulent_eller_virksomhed) | 
         as.logical(Indenrigsministeriet_The_Trade_Council) | 
         as.logical(Produktudviklin)) ~ "Andre Hjælpeordninger",
      
      TRUE ~ "Ingen specifik hjælp"
    )
  ) |>
  # Ryd op ved at fjerne de originale variabler der er brugt til grupperingen
  select(-c(
    Kundeportefølje, Forretningsmodel, Forretningsidé, Produktportefølje,
    Markedsføring, Branding, Kommunikation_og_PR,
    Salg, Eksport, Markedsposition,
    Medarbejdere, Netværk, Samarbejdspartnere, Ejer_og_bestyrelse,
    Økonomistyring, Finansiering, Kapitalfond, Vækstfonden, Innovationsfonden,
    Leverance_og_projektstyring, IT_systemer, Faciliteter, Forretningsgange,
    Juridiske_forhold, Ejerskifte_og_generationsskifte,
    EU_Kontoret_i_DK_Interreg, Erhvervshuset, FN_1, Andre_nationale_ordninger,
    Uddannelse_kompetenceudvikling, Vidensordninger, IV_Vejledning, 
    Virksomhedsbesøg_Virksomhed_under_3_år, I_Værkstedet, 
    Klippekort_Udleveret, Væksthjul_Screening, Agro_Business_Park, 
    Konsulent_virksomhed_uden_for_Kommunen_DK, Lokal_konsulent_eller_virksomhed, 
    Indenrigsministeriet_The_Trade_Council, Produktudviklin
  ))

# Tjek resultatet
glimpse(feature_engineering)


# ------------------------------------------------------------------------------
# 4.9: Behold kun aktive virksomheder
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |> 
  filter(CompanyStatus %in% c("Aktiv", "NORMAL")) |> 
  dplyr::select(-CompanyDateStamp, -CompanyId, -CVR, -PNumber, -Country, 
    -CompanyStatus, -AdvertisingProtected, -MaxParticipants, -Description,
    -EventLength, -EventId, -Andet) # Sletter de kolonner vi ikke vil bruge

# ------------------------------------------------------------------------------
# 4.10: Tilføj churn-kolonne
# Opretter ny kolonne kaldet 'churn',viser om virksomheden er stoppet som medlem. 
# Hvis BusinessCouncilMember er TRUE (virksomheden er medlem), sættes churn = 0
# Hvis BusinessCouncilMember er FALSE (virksomheden har forladt fællesskabet), 
# sættes churn = 1
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |>
  mutate(churn = if_else(BusinessCouncilMember == TRUE, 0, 1)) |>
  select(-BusinessCouncilMember)

# ------------------------------------------------------------------------------
# 4.11: Konverter udvalgte kolonner til faktorer, 
# som er nødvendigt for ML-modeller
# En faktor er en kategorisk variabel – dvs. den indeholder en begrænset mængde 
# unikke værdier (kategorier). # Eksempler på faktorer: postnumre, ja/nej, 
# virksomhedsformer (ApS, A/S, IVS osv.)
# I maskinlæring skal sådanne kolonner være faktorer, 
# så algoritmerne forstår dem som kategorier og ikke som tekst.
# ------------------------------------------------------------------------------
feature_engineering <- feature_engineering |> 
  mutate(
    CompanyTypeName = as.factor(CompanyTypeName),
    har_haft_kontakt = as.factor(har_haft_kontakt),
    deltaget_i_event = as.factor(deltaget_i_event),
    hjælp_kategori = as.factor(hjælp_kategori),
    PostalCode = as.factor(PostalCode),
    churn = as.factor(churn)
  )


# ------------------------------------------------------------------------------
# 4.12: Gem det færdigbehandlede datasæt til senere analyse eller modellering
# ------------------------------------------------------------------------------
write_rds(feature_engineering, "data/feature_engineered_data.rds")

```

5. EDA
```{r}
# EDA
```

6. Preprocessing
```{r}
set.seed(2025)

churn_split <- initial_split(feature_engineering, prop = 0.8, strata = churn)
churn_train <- training(churn_split)
churn_test  <- testing(churn_split)

churn_folds <- vfold_cv(churn_train, v = 10, strata = churn)

churn_recipe <- 
  recipe(churn ~ ., data = churn_train) |>
  step_novel(all_nominal_predictors()) |> 
  step_dummy(all_nominal_predictors(), one_hot = TRUE) |>
  step_zv(all_predictors()) |> 
  step_normalize(all_numeric_predictors()) |> 
  step_downsample(churn)  # Brug evt. step_smote(churn) hvis ekstrem ubalance
```

7. Modelling
```{r}
# Model specs
rf_spec <- rand_forest(mtry = tune(), min_n = tune()) |>
  set_engine("ranger", importance = "impurity") |>
  set_mode("classification")

xgb_spec <- boost_tree(trees = tune(), mtry = tune(), learn_rate = tune()) |>
  set_engine("xgboost") |>
  set_mode("classification")

log_reg_spec <- logistic_reg(penalty = tune(), mixture = tune()) |>
  set_engine("glmnet") |>
  set_mode("classification")

knn_spec <- nearest_neighbor(neighbors = tune(), weight_func = tune()) |>
  set_engine("kknn") |>
  set_mode("classification")

nb_spec <- naive_Bayes(smoothness = tune(), Laplace = tune()) |>
  set_engine("naivebayes") |>
  set_mode("classification")

svm_spec <- svm_rbf(cost = tune(), rbf_sigma = tune()) |>
  set_engine("kernlab") |>
  set_mode("classification")

# Samlet workflow set
churn_workflow_set <- workflow_set(
  preproc = list(churn_recipe = churn_recipe),
  models = list(
    rf = rf_spec,
    xgboost = xgb_spec,
    logistic = log_reg_spec,
    knn = knn_spec,
    naive_bayes = nb_spec,
    svm_rbf = svm_spec
  )
)
```

8. Evaluate metrics
```{r}
churn_metrics <- metric_set(accuracy, roc_auc, f_meas, sens, spec)

grid_ctrl <- control_grid(
  verbose = TRUE,
  save_pred = TRUE,
  parallel_over = "everything",
  save_workflow = TRUE
)

plan(multisession)
strt.time <- Sys.time()

# Man kører modellen - den står og arbejder
# Funktion der siger hvor langt modellen er nået i processen
churn_results <- churn_workflow_set |> 
  workflow_map(
    resamples = churn_folds,
    grid = 5,
    metrics = churn_metrics,
    control = grid_ctrl,
    seed = 2025
  )

Sys.time() - strt.time
plan(sequential)

# Sammenlign resultater
churn_results |> 
  rank_results(select_best = TRUE) |> 
  select(wflow_id, .metric, mean) |> 
  pivot_wider(names_from = .metric, values_from = mean) |> 
  arrange(-f_meas)

autoplot(churn_results, select_best = TRUE)
```

```{r}
# ------------------------------------------------------------------------------
# Visualiseringer
# ------------------------------------------------------------------------------
```


